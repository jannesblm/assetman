package vulnerability

import (
	"encoding/json"
	"errors"
	"github.com/google/uuid"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"sync"
	"time"
)

var ErrorNoApiKey = errors.New("no api key provided")
var ErrorRequestNotFound = errors.New("request not found")

// CPE

type cpeResponse struct {
	Result struct {
		CpeItems []Cpe `json:"cpes"`
	} `json:"result"`
}

type cpeTitles struct {
	Title string `json:"title"`
	Lang  string `json:"lang"`
}

type cpeRefs struct {
	Title string `json:"title"`
	Lang  string `json:"lang"`
}

type Vulnerabilities []string

type Cpe struct {
	Deprecated      bool   `json:"deprecated"`
	Cpe23Uri        string `json:"cpe23uri"`
	LastModified    string `json:"lastModifiedDate"`
	Titles          []cpeTitles
	Refs            []cpeRefs
	Vulnerabilities Vulnerabilities `json:"vulnerabilities"`
}

type CpeResult struct {
	StartedAt time.Time
	Finished  bool
	Error     error
	Cpes      []Cpe
}

type Service interface {
	SearchCpeByKeyword(string) ([]Cpe, error)
	SearchCpeByKeywordAsync(string) string
	GetLastCpe(string) (CpeResult, error)
}

type service struct {
	client   http.Client
	baseUrl  string
	apiKey   string
	cpes     map[string]CpeResult
	cpesLock sync.Mutex
}

func (s *service) buildUrl(path string, params map[string]string) string {
	builder := s.baseUrl

	if !strings.HasSuffix(builder, "/") {
		builder += "/"
	}

	builder += path
	query := ""

	for name, value := range params {
		query += url.QueryEscape(name) + "=" + url.QueryEscape(value) + "&"
	}

	if len(query) > 0 {
		query = query[:len(query)-1]
		builder += "?" + query
	}

	return builder
}

func (s *service) parseResponse(resp *http.Response, v interface{}) error {
	buf, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return err
	}

	return json.Unmarshal(buf, v)
}

func newCpeResult() CpeResult {
	return CpeResult{
		StartedAt: time.Now(),
		Finished:  false,
		Error:     nil,
		Cpes:      []Cpe{},
	}
}

func (s *service) setCpeResult(id string, result CpeResult) {
	s.cpesLock.Lock()
	defer s.cpesLock.Unlock()

	if r, ok := s.cpes[id]; ok {
		result.StartedAt = r.StartedAt
		s.cpes[id] = result
	}
}

// WatchResults periodically checks for un-popped cpes in the map and cleans them up to save memory
func (s *service) WatchResults() chan struct{} {
	ticker := time.NewTicker(10 * time.Second)
	quit := make(chan struct{})

	go func() {
		for {
			select {
			case <-ticker.C:
				for key, cpe := range s.cpes {
					if cpe.StartedAt.Before(time.Now().Add(time.Duration(-1) * time.Minute)) {
						s.cpesLock.Lock()
						delete(s.cpes, key)
						s.cpesLock.Unlock()
					}
				}
			case <-quit:
				ticker.Stop()
				return
			}
		}
	}()

	return quit
}

// SearchCpeByKeyword will query the NVD api with the given keyword and returns
// any results with the associated CVEs.
func (s *service) SearchCpeByKeyword(keyword string) ([]Cpe, error) {
	if len(s.apiKey) == 0 {
		return []Cpe{}, ErrorNoApiKey
	}

	var cpeResp cpeResponse

	resp, err := s.client.Get(s.buildUrl("cpes/1.0/", map[string]string{
		"apiKey":  s.apiKey,
		"keyword": keyword,
		"addOns":  "cves",
	}))

	if err != nil {
		return []Cpe{}, err
	}

	err = s.parseResponse(resp, &cpeResp)

	if err != nil {
		return []Cpe{}, err
	}

	mapped := make([]Cpe, len(cpeResp.Result.CpeItems))

	for i, v := range cpeResp.Result.CpeItems {
		mapped[i] = v
	}

	return mapped, nil
}

// SearchCpeByKeywordAsync will return immediately to work around a Wails bug
// that will block the GUI thread while async calls to backend are running.
// Instead, I am using a fire and poll approach (see GetLastCpe).
func (s *service) SearchCpeByKeywordAsync(keyword string) string {
	id := uuid.NewString()
	s.cpes[id] = newCpeResult()

	go func() {
		res, err := s.SearchCpeByKeyword(keyword)
		s.setCpeResult(id, CpeResult{Finished: true, Error: err, Cpes: res})
	}()

	return id
}

func (s *service) GetLastCpe(id string) (CpeResult, error) {
	defer func() {
		if cpe, ok := s.cpes[id]; ok && cpe.Finished {
			delete(s.cpes, id)
		}
	}()

	if cpe, ok := s.cpes[id]; ok {
		return cpe, cpe.Error
	}

	return CpeResult{}, ErrorRequestNotFound
}

func NewService(baseUrl string, apiKey string) *service {
	return &service{
		client: http.Client{
			Timeout: time.Second * 10,
		},
		baseUrl: baseUrl,
		apiKey:  apiKey,
		cpes:    map[string]CpeResult{},
	}
}
