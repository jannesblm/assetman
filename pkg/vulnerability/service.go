package vulnerability

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

type Cve struct {
	Meta        cveMeta        `json:"CVE_data_meta"`
	Description cveDescription `json:"description"`
	Reference   cveReference   `json:"references"`
}

type cveResponse struct {
	Result struct {
		CveItems []struct {
			Cve Cve `json:"cve"`
		} `json:"CVE_items"`
	} `json:"result"`
}

type cveMeta struct {
	ID       string `json:"ID"`
	Assigner string `json:"ASSIGNER"`
}

type cveDescription struct {
	Data []cveDescriptionData `json:"description_data"`
}

type cveDescriptionData struct {
	Lang  string `json:"lang"`
	Value string `json:"value"`
}

type cveReference struct {
	Data []cveReferenceData `json:"reference_data"`
}

type cveReferenceData struct {
	URL       string   `json:"url"`
	Name      string   `json:"name"`
	RefSource string   `json:"refsource"`
	Tags      []string `json:"tags"`
}

type Service interface {
	SearchByKeyword(keyword string) ([]Cve, error)
}

type service struct {
	client  http.Client
	baseUrl string
	apiKey  string
}

func (s *service) buildUrl(path string, params map[string]string) string {
	builder := s.baseUrl

	if !strings.HasSuffix(builder, "/") {
		builder += "/"
	}

	builder += path
	query := ""

	for name, value := range params {
		query += url.QueryEscape(name) + "=" + url.QueryEscape(value) + "&"
	}

	if len(query) > 0 {
		query = query[:len(query)-1]
		builder += "?" + query
	}

	return builder
}

func (s *service) parseResponse(resp *http.Response, v interface{}) error {
	buf, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return err
	}

	return json.Unmarshal(buf, v)
}

func (s *service) SearchByKeyword(keyword string) ([]Cve, error) {
	var cveResp cveResponse
	resp, err := s.client.Get(s.buildUrl("cves/1.0/", map[string]string{
		"apiKey":  s.apiKey,
		"keyword": keyword,
	}))

	if err != nil {
		return []Cve{}, err
	}

	err = s.parseResponse(resp, &cveResp)

	if err != nil {
		return []Cve{}, err
	}

	mapped := make([]Cve, len(cveResp.Result.CveItems))

	for i, v := range cveResp.Result.CveItems {
		mapped[i] = v.Cve
	}

	return mapped, nil
}

func NewService(baseUrl string, apiKey string) *service {
	return &service{
		client: http.Client{
			Timeout: time.Second * 10,
		},
		baseUrl: baseUrl,
		apiKey:  apiKey,
	}
}
