package vulnerability

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"
)

// CVE

type Cve struct {
	Meta        cveMeta        `json:"CVE_data_meta"`
	Description cveDescription `json:"description"`
	Reference   cveReference   `json:"references"`
}

type cveResponse struct {
	Result struct {
		CveItems []struct {
			Cve Cve `json:"cve"`
		} `json:"CVE_items"`
	} `json:"result"`
}

type cveMeta struct {
	ID       string `json:"ID"`
	Assigner string `json:"ASSIGNER"`
}

type cveDescription struct {
	Data []cveDescriptionData `json:"description_data"`
}

type cveDescriptionData struct {
	Lang  string `json:"lang"`
	Value string `json:"value"`
}

type cveReference struct {
	Data []cveReferenceData `json:"reference_data"`
}

type cveReferenceData struct {
	URL       string   `json:"url"`
	Name      string   `json:"name"`
	RefSource string   `json:"refsource"`
	Tags      []string `json:"tags"`
}

// CPE

type cpeResponse struct {
	Result struct {
		CpeItems []Cpe `json:"cpes"`
	} `json:"result"`
}

type cpeTitles struct {
	Title string `json:"title"`
	Lang  string `json:"lang"`
}

type cpeRefs struct {
	Title string `json:"title"`
	Lang  string `json:"lang"`
}

type Vulnerabilities []string

type Cpe struct {
	Deprecated      bool   `json:"deprecated"`
	Cpe23Uri        string `json:"cpe23uri"`
	LastModified    string `json:"lastModifiedDate"`
	Titles          []cpeTitles
	Refs            []cpeRefs
	Vulnerabilities Vulnerabilities `json:"vulnerabilities"`
}

type Service interface {
	SearchCveByKeyword(keyword string) ([]Cve, error)
	SearchCpeByKeyword(keyword string)
	GetLastCPE() []Cpe
}

type service struct {
	client    http.Client
	baseUrl   string
	apiKey    string
	lastError error
	LastCPE   []Cpe
}

func (s *service) buildUrl(path string, params map[string]string) string {
	builder := s.baseUrl

	if !strings.HasSuffix(builder, "/") {
		builder += "/"
	}

	builder += path
	query := ""

	for name, value := range params {
		query += url.QueryEscape(name) + "=" + url.QueryEscape(value) + "&"
	}

	if len(query) > 0 {
		query = query[:len(query)-1]
		builder += "?" + query
	}

	return builder
}

func (s *service) parseResponse(resp *http.Response, v interface{}) error {
	buf, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		return err
	}

	return json.Unmarshal(buf, v)
}

func (s *service) SearchCveByKeyword(keyword string) ([]Cve, error) {
	var cveResp cveResponse

	resp, err := s.client.Get(s.buildUrl("cves/1.0/", map[string]string{
		"apiKey":  s.apiKey,
		"keyword": keyword,
	}))

	if err != nil {
		return []Cve{}, err
	}

	err = s.parseResponse(resp, &cveResp)

	if err != nil {
		return []Cve{}, err
	}

	mapped := make([]Cve, len(cveResp.Result.CveItems))

	for i, v := range cveResp.Result.CveItems {
		mapped[i] = v.Cve
	}

	return mapped, nil
}

func (s *service) SearchCpeByKeyword(keyword string) {
	var cpeResp cpeResponse

	go func() {
		resp, err := s.client.Get(s.buildUrl("cpes/1.0/", map[string]string{
			"apiKey":  s.apiKey,
			"keyword": keyword,
			"addOns":  "cves",
		}))

		if err != nil {
			s.lastError = err
			return
		}

		err = s.parseResponse(resp, &cpeResp)

		if err != nil {
			s.lastError = err
			return
		}

		mapped := make([]Cpe, len(cpeResp.Result.CpeItems))

		for i, v := range cpeResp.Result.CpeItems {
			mapped[i] = v
		}

		s.LastCPE = mapped
	}()
}

func (s *service) GetLastCpe() []Cpe {
	defer func() {
		s.LastCPE = []Cpe{}
	}()

	return s.LastCPE
}

func NewService(baseUrl string, apiKey string) *service {
	return &service{
		client: http.Client{
			Timeout: time.Second * 10,
		},
		baseUrl: baseUrl,
		apiKey:  apiKey,
	}
}
